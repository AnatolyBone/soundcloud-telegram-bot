const { Telegraf, Markup } = require('telegraf');
const express = require('express');
const fs = require('fs');
const path = require('path');
const ytdl = require('youtube-dl-exec');
const { google } = require('googleapis');

const {
  createUser,
  getUser,
  updateUserField,
  incrementDownloads,
  setPremium,
  getAllUsers
} = require('./db');

const BOT_TOKEN = process.env.BOT_TOKEN;
const ADMIN_ID = parseInt(process.env.ADMIN_ID, 10);
const WEBHOOK_URL = 'https://soundcloud-telegram-bot.onrender.com/telegram';

const SCOPES = ['https://www.googleapis.com/auth/drive.file'];
const auth = new google.auth.GoogleAuth({
  keyFile: path.join(__dirname, 'service-account.json'),
  scopes: SCOPES,
});
const drive = google.drive({ version: 'v3', auth });

async function uploadBackup(filename, filepath) {
  try {
    await drive.files.create({
      requestBody: {
        name: filename,
        parents: ['1FjRTVO4rLCsKdeIg452M4-1MjpmfuChG']
      },
      media: {
        body: fs.createReadStream(filepath),
      },
    });
    console.log('‚úÖ Backup uploaded:', filename);
  } catch (err) {
    console.error('‚ùå Backup upload failed:', err);
  }
}

const app = express();
const bot = new Telegraf(BOT_TOKEN);

const cacheDir = path.join(__dirname, 'cache');
if (!fs.existsSync(cacheDir)) fs.mkdirSync(cacheDir);

// –û—á–∏—Å—Ç–∫–∞ –∫–µ—à–∞ —Å—Ç–∞—Ä—à–µ 7 –¥–Ω–µ–π
setInterval(() => {
  const cutoff = Date.now() - 7 * 86400 * 1000;
  fs.readdirSync(cacheDir).forEach(file => {
    const fp = path.join(cacheDir, file);
    if (fs.statSync(fp).mtimeMs < cutoff) fs.unlinkSync(fp);
  });
}, 3600 * 1000);

// –ë—ç–∫–∞–ø –±–∞–∑—ã —Ä–∞–∑ –≤ —Å—É—Ç–∫–∏
setInterval(async () => {
  const src = path.join(__dirname, 'database.sqlite');
  if (!fs.existsSync(src)) {
    console.warn('‚ùó No database.sqlite found for backup');
    return;
  }
  const fname = `backup_${Date.now()}.sqlite`;
  const dst = path.join(__dirname, fname);
  fs.copyFileSync(src, dst);
  console.log('üìÅ Backup file created:', fname);
  await uploadBackup(fname, dst);
  fs.unlinkSync(dst);
}, 24 * 3600 * 1000);

const texts = {
  ru: {
    start: 'üëã –ü—Ä–∏—à–ª–∏ —Å—Å—ã–ª–∫—É –Ω–∞ —Ç—Ä–µ–∫ —Å SoundCloud.',
    menu: 'üìã –ú–µ–Ω—é', upgrade: 'üîì –†–∞—Å—à–∏—Ä–∏—Ç—å –ª–∏–º–∏—Ç',
    mytracks: 'üéµ –ú–æ–∏ —Ç—Ä–µ–∫–∏', help: '‚ÑπÔ∏è –ü–æ–º–æ—â—å',
    downloading: 'üéß –ó–∞–≥—Ä—É–∂–∞—é...', cached: 'üîÅ –ò–∑ –∫–µ—à–∞...',
    error: '‚ùå –û—à–∏–±–∫–∞', timeout: '‚è± –°–ª–∏—à–∫–æ–º –¥–æ–ª–≥–æ...', limitReached: 'üö´ –õ–∏–º–∏—Ç –¥–æ—Å—Ç–∏–≥–Ω—É—Ç.',
    upgradeInfo:
      'üöÄ –•–æ—á–µ—à—å –±–æ–ª—å—à–µ —Ç—Ä–µ–∫–æ–≤?\n\nüÜì Free ‚Äì 10 üü¢\nPlus ‚Äì 50 üéØ (59‚ÇΩ)\nPro ‚Äì 100 üí™ (119‚ÇΩ)\nUnlimited ‚Äì üíé (199‚ÇΩ)\n\nüëâ –î–æ–Ω–∞—Ç: https://boosty.to/anatoly_bone/donate\n‚úâÔ∏è –ü–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã –∂–º–∏ ‚Äú–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –æ–ø–ª–∞—Ç—É‚Äù',
    helpInfo: '‚ÑπÔ∏è –ü—Ä–æ—Å—Ç–æ –ø—Ä–∏—à–ª–∏ —Å—Å—ã–ª–∫—É –∏ –ø–æ–ª—É—á–∏—à—å mp3.\nüîì –†–∞—Å—à–∏—Ä–∏—Ç—å ‚Äî –æ–ø–ª–∞—Ç–∏ –∏ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏.\nüéµ –ú–æ–∏ —Ç—Ä–µ–∫–∏ ‚Äî —Å–ø–∏—Å–æ–∫ –∑–∞ —Å–µ–≥–æ–¥–Ω—è.\nüìã –ú–µ–Ω—é ‚Äî —Å–º–µ–Ω–∞ —è–∑—ã–∫–∞.',
    chooseLang: 'üåê –í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫:',
    backupError: '‚ùå –û—à–∏–±–∫–∞ –±—ç–∫–∞–ø–∞',
    backupDone: '‚úÖ –ë—ç–∫–∞–ø –≤—ã–ø–æ–ª–Ω–µ–Ω'
  },
  en: {
    start: 'üëã Send a SoundCloud track link.',
    menu: 'üìã Menu', upgrade: 'üîì Upgrade limit',
    mytracks: 'üéµ My tracks', help: '‚ÑπÔ∏è Help',
    downloading: 'üéß Downloading...', cached: 'üîÅ From cache...',
    error: '‚ùå Error', timeout: '‚è± Timeout...', limitReached: 'üö´ Limit reached.',
    upgradeInfo:
      'üöÄ Want more tracks?\n\nüÜì Free ‚Äì 10 üü¢\nPlus ‚Äì 50 üéØ (59‚ÇΩ)\nPro ‚Äì 100 üí™ (119‚ÇΩ)\nUnlimited ‚Äì üíé (199‚ÇΩ)\n\nüëâ Donate: https://boosty.to/anatoly_bone/donate\n‚úâÔ∏è After payment press ‚ÄúConfirm payment‚Äù',
    helpInfo: '‚ÑπÔ∏è Just send a SoundCloud link to get mp3.\nüîì Upgrade ‚Äî pay and confirm.\nüéµ My tracks ‚Äî list of today\'s downloads.\nüìã Menu ‚Äî change language.',
    chooseLang: 'üåê Choose language:',
    backupError: '‚ùå Backup error',
    backupDone: '‚úÖ Backup done'
  }
};

const kb = lang =>
  Markup.keyboard([
    [texts[lang].menu, texts[lang].upgrade],
    [texts[lang].mytracks, texts[lang].help],
    ['‚úçÔ∏è –û—Å—Ç–∞–≤–∏—Ç—å –æ—Ç–∑—ã–≤']
  ]).resize();

const getLang = (u) => (u?.lang || 'ru');

bot.start(async (ctx) => {
  const { id, username, first_name } = ctx.from;
  await createUser(id, username, first_name);
  const u = await getUser(id);
  ctx.reply(texts[getLang(u)].start, kb(getLang(u)));
});

bot.hears([texts.ru.menu, texts.en.menu], async (ctx) => {
  const u = await getUser(ctx.from.id);
  ctx.reply(texts[getLang(u)].chooseLang, Markup.inlineKeyboard([
    Markup.button.callback('üá∑üá∫ –†—É—Å—Å–∫–∏–π', 'lang_ru'),
    Markup.button.callback('üá¨üáß English', 'lang_en')
  ]));
});

bot.action(/lang_(\w+)/, async (ctx) => {
  const lang = ctx.match[1];
  await updateUserField(ctx.from.id, 'lang', lang);
  ctx.editMessageText(texts[lang].chooseLang + ' ‚úÖ');
  ctx.reply(texts[lang].start, kb(lang));
});

bot.hears([texts.ru.upgrade, texts.en.upgrade], async ctx => {
  const u = await getUser(ctx.from.id);
  ctx.reply(texts[getLang(u)].upgradeInfo);
});
bot.hears([texts.ru.help, texts.en.help], async ctx => {
  const u = await getUser(ctx.from.id);
  ctx.reply(texts[getLang(u)].helpInfo);
});

bot.hears([texts.ru.mytracks, texts.en.mytracks], async ctx => {
  const u = await getUser(ctx.from.id);
  const list = u.tracks_today?.split(',').filter(Boolean) || [];
  if (!list.length) return ctx.reply('–°–µ–≥–æ–¥–Ω—è –Ω–µ—Ç —Ç—Ä–µ–∫–æ–≤.');
  const media = list.map(name => {
    const fp = path.join(cacheDir, `${name}.mp3`);
    return fs.existsSync(fp) ? { type: 'audio', media: { source: fp } } : null;
  }).filter(Boolean);
  for (let i = 0; i < media.length; i += 10) {
    ctx.replyWithMediaGroup(media.slice(i, i + 10));
  }
});

bot.command('testdb', async ctx => {
  const u = await getUser(ctx.from.id);
  if (u) {
    ctx.reply(`ID: ${u.id}\n–°–µ–≥–æ–¥–Ω—è: ${u.downloads_today}/${u.premium_limit}`);
  } else ctx.reply('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω');
});

bot.command('admin', async ctx => {
  if (ctx.from.id !== ADMIN_ID) return;
  const users = await getAllUsers();
  const files = fs.readdirSync(cacheDir);
  const totalSize = files.reduce((s, f) => s + fs.statSync(path.join(cacheDir, f)).size, 0);
  const free = users.filter(u => u.premium_limit === 10).length;
  const plus = users.filter(u => u.premium_limit === 50).length;
  const pro = users.filter(u => u.premium_limit === 100).length;
  const unlimited = users.filter(u => u.premium_limit >= 1000).length;
  const totalDownloads = users.reduce((s, u) => s + u.total_downloads, 0);
  const summary = `üìä –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏: ${users.length}\nüì• –ó–∞–≥—Ä—É–∑–æ–∫: ${totalDownloads}\nüìÅ –ö–µ—à: ${files.length} —Ñ–∞–π–ª–æ–≤, ${(totalSize/1024/1024).toFixed(1)} MB\n\nüÜì Free: ${free}\nüéØ Plus: ${plus}\nüí™ Pro: ${pro}\nüíé Unlimited: ${unlimited}`;
  ctx.reply(summary);
  const buttons = users.map(u => {
    const name = u.username ? '@' + u.username : u.id;
    return Markup.button.callback(`${name} | ${u.downloads_today}/${u.premium_limit}`, `user_${u.id}`);
  });
  ctx.reply('üë• –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏:', Markup.inlineKeyboard(buttons, { columns: 1 }));
});
bot.command('reviews', async ctx => {
  if (ctx.from.id !== ADMIN_ID) return;
  const file = path.join(__dirname, 'reviews.json');
  if (!fs.existsSync(file)) return ctx.reply('‚ùå –û—Ç–∑—ã–≤–æ–≤ –ø–æ–∫–∞ –Ω–µ—Ç.');
  const reviews = JSON.parse(fs.readFileSync(file, 'utf8'));

  if (!reviews.length) return ctx.reply('‚ùå –û—Ç–∑—ã–≤–æ–≤ –ø–æ–∫–∞ –Ω–µ—Ç.');

  for (const r of reviews.slice(-10).reverse()) {
    const user = r.username ? `@${r.username}` : `${r.name || r.id}`;
    await ctx.reply(`üó£ ${user}\nüïí ${new Date(r.date).toLocaleString()}\n\n${r.text}`);
  }
});
bot.action(/user_(\d+)/, async ctx => {
  if (ctx.from.id !== ADMIN_ID) return;
  const id = ctx.match[1];
  ctx.reply('üí≥ –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∞—Ä–∏—Ñ:', Markup.inlineKeyboard([
    Markup.button.callback('Plus (50)', `plan_${id}_50`),
    Markup.button.callback('Pro (100)', `plan_${id}_100`),
    Markup.button.callback('Unlimited (‚àû)', `plan_${id}_1000`)
  ]));
});

bot.action(/plan_(\d+)_(\d+)/, async ctx => {
  if (ctx.from.id !== ADMIN_ID) return;
  const [_, id, limit] = ctx.match;
  await updateUserField(+id, 'premium_limit', +limit);
  await updateUserField(+id, 'premium_end', Date.now() + 30 * 86400 * 1000);
  ctx.reply('‚úÖ –¢–∞—Ä–∏—Ñ –∏–∑–º–µ–Ω—ë–Ω');
});

let queue = [];

bot.on('text', async (ctx) => {
  const text = ctx.message.text.trim();
  const userId = ctx.from.id;
  const u = await getUser(userId);
  const lang = getLang(u);

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ —Å—Å—ã–ª–∫–∞ SoundCloud
  if (!text.startsWith('https://soundcloud.com/')) {
    return ctx.reply(texts[lang].start);
  }

  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–º–∏—Ç–∞
  if (u.downloads_today >= u.premium_limit) {
    return ctx.reply(texts[lang].limitReached);
  }

  // –î–æ–±–∞–≤–ª—è–µ–º –≤ –æ—á–µ—Ä–µ–¥—å
  queue.push({ text, ctx });
  ctx.reply(`‚è≥ –¢—Ä–µ–∫ –¥–æ–±–∞–≤–ª–µ–Ω –≤ –æ—á–µ—Ä–µ–¥—å (#${queue.length})`);

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—á–µ—Ä–µ–¥–∏ (–µ—Å–ª–∏ –µ—â—ë –Ω–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è)
  if (queue.length === 1) {
    while (queue.length > 0) {
      const item = queue[0];
      const { text: trackUrl, ctx: trackCtx } = item;

      try {
        await trackCtx.reply(texts[lang].downloading);

        // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ –æ —Ç—Ä–µ–∫–µ
        const info = await ytdl(trackUrl, { dumpSingleJson: true });
        if (!info || !info.title) throw new Error('No info');
        const name = info.title.replace(/[^\w\d]/g, '_').slice(0, 50);
        const fp = path.join(cacheDir, `${name}.mp3`);

        if (fs.existsSync(fp)) {
          await trackCtx.reply(texts[lang].cached);
        } else {
          await ytdl(trackUrl, {
            '--extract-audio': true,
            '--audio-format': 'mp3',
            '-o': fp,
            '--no-warnings': true,
            '--no-check-certificate': true,
            '--prefer-free-formats': true,
            '--youtube-skip-dash-manifest': true,
          });
        }

        await incrementDownloads(userId, name);

        await trackCtx.replyWithAudio({ source: fs.createReadStream(fp), filename: `${name}.mp3` });
      } catch (e) {
        console.error('Download error:', e);
        await trackCtx.reply(texts[lang].error);
      }

      queue.shift();
    }
  }
});

bot.launch({
  webhook: {
    domain: 'soundcloud-telegram-bot.onrender.com',
    port: process.env.PORT || 3000,
    hookPath: '/telegram',
  }
});

app.use(bot.webhookCallback('/telegram'));
app.get('/', (req, res) => res.send('SoundCloud Telegram Bot is running.'));
app.listen(process.env.PORT || 3000);

process.once('SIGINT', () => bot.stop('SIGINT'));
process.once('SIGTERM', () => bot.stop('SIGTERM'));