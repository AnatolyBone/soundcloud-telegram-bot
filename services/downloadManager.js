// services/downloadManager.js

import path from 'path';
import fs from 'fs';
import ytdl from 'youtube-dl-exec';
import { fileURLToPath } from 'url';
import crypto from 'crypto';

import { TaskQueue } from '../lib/TaskQueue.js';
import { getRedisClient, texts, bot } from '../index.js';
import {
    getUser, resetDailyLimitIfNeeded, saveTrackForUser, logEvent,
    incrementDownloads, updateUserField, findCachedTracksByUrls, cacheTrack
} from '../db.js';

// =======================================================
// --- 1. –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è ---
// =======================================================

const CONFIG = {
    TELEGRAM_FILE_LIMIT_MB: 49,
    MAX_PLAYLIST_TRACKS_FREE: 10,
    TRACK_TITLE_LIMIT: 100,
    MAX_CONCURRENT_DOWNLOADS: 2, // –°–Ω–∏–∂–µ–Ω–æ –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏ –Ω–∞ Render
    YTDL_RETRIES: 3,
    SOCKET_TIMEOUT: 120,
};

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(path.dirname(__filename));
const cacheDir = path.join(__dirname, 'cache');

// =======================================================
// --- 2. –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —É—Ç–∏–ª–∏—Ç—ã ---
// =======================================================

function sanitizeFilename(name) {
    return (name || 'track').replace(/[<>:"/\\|?*]+/g, '').trim().slice(0, CONFIG.TRACK_TITLE_LIMIT);
}

async function safeSendMessage(userId, text, extra = {}) {
    try {
        return await bot.telegram.sendMessage(userId, text, extra);
    } catch (e) {
        if (e.response?.error_code === 403) {
            console.warn(`[SafeSend] –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${userId} –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª –±–æ—Ç–∞.`);
            await updateUserField(userId, 'active', false);
        } else {
            console.error(`[SafeSend] –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è ${userId}:`, e.message);
        }
        return null;
    }
}

function getYtdlErrorMessage(err) {
    if (err.stderr) {
        if (err.stderr.includes('Unsupported URL')) return '–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–∞—è —Å—Å—ã–ª–∫–∞.';
        if (err.stderr.includes('Video unavailable')) return '–¢—Ä–µ–∫ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.';
        if (err.stderr.includes('404')) return '–¢—Ä–µ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω (–æ—à–∏–±–∫–∞ 404).';
    }
    if (err.message.includes('timed out')) return '–°–µ—Ä–≤–∏—Å –æ—Ç–≤–µ—á–∞–µ—Ç —Å–ª–∏—à–∫–æ–º –¥–æ–ª–≥–æ.';
    return '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ.';
}

// =======================================================
// --- 3. –í–æ—Ä–∫–µ—Ä –∏ –æ—á–µ—Ä–µ–¥—å –∑–∞–¥–∞—á ---
// =======================================================

async function trackDownloadProcessor(task) {
    const { userId, url, trackName, uploader, playlistUrl } = task;
    const tempFilename = `${sanitizeFilename(trackName)}-${crypto.randomUUID()}.mp3`;
    const tempFilePath = path.join(cacheDir, tempFilename);

    try {
        console.log(`[Worker] –ù–∞—á–∏–Ω–∞—é —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ: ${trackName}`);
        
        await ytdl(url, {
            extractAudio: true,
            audioFormat: 'mp3',
            output: tempFilePath,
            embedMetadata: true,
            postprocessorArgs: `-metadata artist="${uploader || 'SoundCloud'}" -metadata title="${trackName}"`,
            retries: CONFIG.YTDL_RETRIES,
            "socket-timeout": CONFIG.SOCKET_TIMEOUT,
        });

        if (!fs.existsSync(tempFilePath)) {
            throw new Error(`–§–∞–π–ª –Ω–µ –±—ã–ª —Å–æ–∑–¥–∞–Ω –ø–æ—Å–ª–µ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è: ${tempFilePath}`);
        }

        const stats = await fs.promises.stat(tempFilePath);
        if (stats.size / (1024 * 1024) > CONFIG.TELEGRAM_FILE_LIMIT_MB) {
            await safeSendMessage(userId, `‚ö†Ô∏è –¢—Ä–µ–∫ "${trackName}" —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π –∏ –±—ã–ª –ø—Ä–æ–ø—É—â–µ–Ω.`);
            return;
        }
        
        const sentMessage = await bot.telegram.sendAudio(userId, { source: fs.createReadStream(tempFilePath) }, {
            caption: trackName, title: trackName, performer: uploader || 'SoundCloud'
        });
        
        if (sentMessage?.audio?.file_id) {
            await cacheTrack(url, sentMessage.audio.file_id, trackName);
            await saveTrackForUser(userId, trackName, sentMessage.audio.file_id);
            await incrementDownloads(userId);
        }
        
        if (playlistUrl) {
            const redisClient = getRedisClient();
            const playlistKey = `playlist:${userId}:${playlistUrl}`;
            const remaining = await redisClient.decr(playlistKey);
            if (remaining <= 0) {
                await safeSendMessage(userId, '‚úÖ –í—Å–µ —Ç—Ä–µ–∫–∏ –∏–∑ –ø–ª–µ–π–ª–∏—Å—Ç–∞ –∑–∞–≥—Ä—É–∂–µ–Ω—ã.');
                await redisClient.del(playlistKey);
            }
        }
        
    } catch (err) {
        await safeSendMessage(userId, `‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Ç—Ä–µ–∫: "${trackName}"`);
        console.error(`‚ùå –û—à–∏–±–∫–∞ –≤–æ—Ä–∫–µ—Ä–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ "${trackName}":`, err.stderr || err.message || err);
    } finally {
        if (fs.existsSync(tempFilePath)) {
            await fs.promises.unlink(tempFilePath).catch(e => console.error(`–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª ${tempFilePath}:`, e));
        }
    }
}

export const downloadQueue = new TaskQueue({
    maxConcurrent: CONFIG.MAX_CONCURRENT_DOWNLOADS,
    taskProcessor: trackDownloadProcessor
});

// ======================================================================
// --- 4. –ö–æ–Ω–≤–µ–π–µ—Ä –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–ø—Ä–æ—Å–∞ (Enqueue Pipeline) ---
// ======================================================================

async function getTracksInfo(url) {
    const info = await ytdl(url, {
        dumpSingleJson: true,
        retries: CONFIG.YTDL_RETRIES,
        "socket-timeout": CONFIG.SOCKET_TIMEOUT
    });

    const isPlaylist = Array.isArray(info.entries) && info.entries.length > 0;
    
    const tracks = isPlaylist
        ? info.entries.filter(e => e?.webpage_url && e?.id).map(e => ({
            url: e.webpage_url,
            trackName: sanitizeFilename(e.title),
            uploader: e.uploader || 'SoundCloud'
          }))
        : [{
            url: info.webpage_url || url,
            trackName: sanitizeFilename(info.title),
            uploader: info.uploader || 'SoundCloud'
          }];
    
    if (tracks.length === 0) throw new Error("–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Ç—Ä–µ–∫–∏ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏.");
    
    return { tracks, isPlaylist };
}

function applyUserLimits(tracks, user, isPlaylist) {
    let limitedTracks = [...tracks];

    if (isPlaylist && user.premium_limit <= 10 && limitedTracks.length > CONFIG.MAX_PLAYLIST_TRACKS_FREE) {
        safeSendMessage(user.id, `‚ÑπÔ∏è –ë–µ—Å–ø–ª–∞—Ç–Ω—ã–π —Ç–∞—Ä–∏—Ñ: –º–æ–∂–Ω–æ —Å–∫–∞—á–∞—Ç—å –¥–æ ${CONFIG.MAX_PLAYLIST_TRACKS_FREE} —Ç—Ä–µ–∫–æ–≤ –∏–∑ –ø–ª–µ–π–ª–∏—Å—Ç–∞.`);
        limitedTracks = limitedTracks.slice(0, CONFIG.MAX_PLAYLIST_TRACKS_FREE);
    }

    return limitedTracks;
}

async function sendCachedTracks(tracks, userId) {
    const urls = tracks.map(t => t.url);
    const cachedTracksMap = await findCachedTracksByUrls(urls);
    
    const tasksToDownload = [];
    let sentFromCacheCount = 0;

    for (const track of tracks) {
        const cached = cachedTracksMap.get(track.url);
        if (cached) {
            try {
                await bot.telegram.sendAudio(userId, cached.fileId, { caption: track.trackName, title: track.trackName });
                await saveTrackForUser(userId, track.trackName, cached.fileId);
                await incrementDownloads(userId);
                sentFromCacheCount++;
            } catch (err) {
                if (err.description?.includes('FILE_REFERENCE_EXPIRED')) {
                    tasksToDownload.push(track);
                } else {
                    console.error(`‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∏–∑ –∫—ç—à–∞ –¥–ª—è ${userId}: ${err.message}`);
                }
            }
        } else {
            tasksToDownload.push(track);
        }
    }

    if (sentFromCacheCount > 0) {
        await safeSendMessage(userId, `‚úÖ ${sentFromCacheCount} —Ç—Ä–µ–∫(–æ–≤) –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –º–≥–Ω–æ–≤–µ–Ω–Ω–æ –∏–∑ –∫—ç—à–∞.`);
    }

    return tasksToDownload;
}

async function queueRemainingTracks(tracks, userId, isPlaylist, originalUrl) {
    if (tracks.length === 0) return;

    const user = await getUser(userId);
    const remainingLimit = user.premium_limit - user.downloads_today;

    if (remainingLimit <= 0) {
        return safeSendMessage(userId, 'üö´ –í–∞—à –ª–∏–º–∏—Ç –±—ã–ª –∏—Å—á–µ—Ä–ø–∞–Ω —Ç—Ä–µ–∫–∞–º–∏, –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–º–∏ –∏–∑ –∫—ç—à–∞.');
    }

    let finalTasks = tracks;
    if (tracks.length > remainingLimit) {
        await safeSendMessage(userId, `‚ö†Ô∏è –í–∞—à –ª–∏–º–∏—Ç: ${remainingLimit}. –î–æ–±–∞–≤–ª—è—é –≤ –æ—á–µ—Ä–µ–¥—å —Ç–æ–ª—å–∫–æ –¥–æ—Å—Ç—É–ø–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç—Ä–µ–∫–æ–≤.`);
        finalTasks = tracks.slice(0, remainingLimit);
    }
    
    if (finalTasks.length > 0) {
        await safeSendMessage(userId, `‚è≥ –î–æ–±–∞–≤–ª–µ–Ω–æ –≤ –æ—á–µ—Ä–µ–¥—å ${finalTasks.length} —Ç—Ä–µ–∫(–æ–≤). –í—ã –ø–æ–ª—É—á–∏—Ç–µ –∏—Ö –ø–æ –º–µ—Ä–µ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏.`);
        
        if (isPlaylist) {
            const redisClient = getRedisClient();
            const playlistKey = `playlist:${userId}:${originalUrl}`;
            await redisClient.setEx(playlistKey, 3600, finalTasks.length.toString());
            await logEvent(userId, 'download_playlist', { url: originalUrl });
        }
        
        for (const track of finalTasks) {
            downloadQueue.add({
                userId,
                ...track,
                playlistUrl: isPlaylist ? originalUrl : null,
                priority: user.premium_limit
            });
            await logEvent(userId, 'download_start', { url: track.url, title: track.trackName });
        }
    }
}


// =======================================================
// --- 5. –û—Å–Ω–æ–≤–Ω–∞—è –≤—Ö–æ–¥–Ω–∞—è —Ç–æ—á–∫–∞ ---
// =======================================================

export async function enqueue(ctx, userId, url) {
    const processingMessage = await safeSendMessage(userId, 'üîç –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é —Å—Å—ã–ª–∫—É...');

    try {
        await resetDailyLimitIfNeeded(userId);
        const user = await getUser(userId);

        if ((user.premium_limit - user.downloads_today) <= 0) {
            await safeSendMessage(userId, texts.limitReached);
            return;
        }

        const { tracks, isPlaylist } = await getTracksInfo(url);
        const limitedTracks = applyUserLimits(tracks, user, isPlaylist);
        const tasksToDownload = await sendCachedTracks(limitedTracks, userId);
        await queueRemainingTracks(tasksToDownload, userId, isPlaylist, url);

    } catch (err) {
        console.error(`‚ùå –ì–ª–æ–±–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞ –≤ enqueue –¥–ª—è userId ${userId}:`, err.stderr || err.message);
        const userFriendlyError = getYtdlErrorMessage(err);
        await safeSendMessage(userId, `‚ùå –û—à–∏–±–∫–∞: ${userFriendlyError}`);
    } finally {
        if (processingMessage) {
            await bot.telegram.deleteMessage(userId, processingMessage.message_id).catch(() => {});
        }
    }
}